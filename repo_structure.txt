=========================================
REPOSITORY STRUCTURE AND CONTENT
Generated on: Mon Aug 18 11:20:02 MDT 2025
=========================================

DIRECTORY TREE:
---------------
.
├── .rspec
├── .rubocop.yml
├── .ruby-lsp
│   ├── .gitignore
│   ├── Gemfile
│   ├── Gemfile.lock
│   ├── last_updated
│   └── main_lockfile_hash
├── .vscode
│   └── launch.json
├── bin
│   └── rspec
├── chess.zip
├── flatten_repo_script.sh
├── Gemfile
├── Gemfile.lock
├── lib
│   ├── chess
│   │   ├── core
│   │   │   ├── board.rb
│   │   │   ├── game.rb
│   │   │   ├── move_history.rb
│   │   │   ├── move.rb
│   │   │   └── position.rb
│   │   ├── data
│   │   │   ├── config.rb
│   │   │   ├── directions_data.rb
│   │   │   └── piece_data.rb
│   │   ├── helpers
│   │   │   ├── chess_notation.rb
│   │   │   ├── colorize_string.rb
│   │   │   ├── display.rb
│   │   │   ├── from_fen.rb
│   │   │   ├── interface.rb
│   │   │   ├── piece_helpers.rb
│   │   │   └── to_fen.rb
│   │   └── services
│   │       ├── castling_validator.rb
│   │       ├── check_detector.rb
│   │       ├── move_calculator.rb
│   │       ├── move_validator.rb
│   │       └── pawn_move_validator.rb
│   └── chess.rb
├── main.rb
├── README.md
├── repo_structure.txt
├── spec
│   ├── chess
│   │   ├── core
│   │   │   ├── board_spec.rb
│   │   │   ├── game_spec.rb
│   │   │   ├── move_history_spec.rb
│   │   │   ├── move_spec.rb
│   │   │   └── position_spec.rb
│   │   ├── helpers
│   │   │   ├── display_spec.rb
│   │   │   └── interface_spec.rb
│   │   └── services
│   │       ├── castling_validator_spec.rb
│   │       ├── check_detector.rb
│   │       ├── move_calculator_spec.rb
│   │       ├── move_validator_spec.rb
│   │       └── pawn_move_validator_spec.rb
│   └── spec_helper.rb
└── spike
    └── interface.rb

16 directories, 51 files


FILE CONTENTS:
-------------

================================================
FILE: ./.ruby-lsp/last_updated
================================================
2025-08-10T08:36:07-06:00

================================================
FILE: ./.ruby-lsp/main_lockfile_hash
================================================
2e957ee8d1bdb4352f0f1c13110a8d86a055530ae8cbdfe9cb1802e878fcba90

================================================
FILE: ./lib/chess.rb
================================================
# frozen_string_literal: true

require_relative 'chess/data/config'
require_relative 'chess/data/directions_data'
require_relative 'chess/data/piece_data'

require_relative 'chess/helpers/chess_notation'
require_relative 'chess/helpers/colorize_string'
require_relative 'chess/helpers/display'
require_relative 'chess/helpers/from_fen'
require_relative 'chess/helpers/interface'
require_relative 'chess/helpers/piece_helpers'
require_relative 'chess/helpers/to_fen'

require_relative 'chess/services/check_detector'
require_relative 'chess/services/castling_validator'
require_relative 'chess/services/move_calculator'
require_relative 'chess/services/move_validator'
require_relative 'chess/services/pawn_move_validator'

require_relative 'chess/core/board'
require_relative 'chess/core/game'
require_relative 'chess/core/move_history'
require_relative 'chess/core/move'
require_relative 'chess/core/position'

# top-level namespace for organization
# and contain the library files for
# easy loading
module Chess
end


================================================
FILE: ./lib/chess/core/board.rb
================================================
# frozen_string_literal: true

module Chess
  # Board represents a chess board.
  #
  # It contains the game board
  # and manages the rules of
  # the game.
  #
  # @example Create a new Board
  # board = Board.new
  #
  class Board
    extend ChessNotation
    attr_accessor :grid, :castling_rights, :en_passant_square

    def initialize(grid: self.class.empty_grid,
                   castling_rights: self.class.default_castling_rights,
                   en_passant_square: nil)
      @grid = grid
      @castling_rights = castling_rights
      @en_passant_square = en_passant_square
    end

    class << self
      def start_positions(add_pieces: true)
        setup_starting_grid = add_pieces ? setup_pieces(empty_grid) : empty_grid
        new(grid: setup_starting_grid)
      end

      def from_fen(fen_string)
        parsed_data = FromFEN.to_piece_placement(fen_string)
        new(**parsed_data)
      end

      def empty_grid
        Array.new(Config::GRID_LENGTH) { Array.new(Config::GRID_LENGTH) }
      end

      def default_castling_rights
        {
          white_castle_kingside: true,
          white_castle_queenside: true,
          black_castle_kingside: true,
          black_castle_queenside: true
        }
      end

      private

      def setup_pieces(grid)
        Piece::START_POSITIONS.each do |(rank, file), piece|
          grid[rank][file] = piece
        end
        grid
      end
    end

    def to_display
      grid.map { |rank| rank.map { |file| file.nil? ? '' : file.to_s } }
    end

    def to_fen
      {
        grid: grid,
        castling_rights: castling_rights,
        en_passant_square: en_passant_square
      }
    end

    def piece_at(position)
      grid[position.row][position.column]
    end

    def find_king(color)
      target_piece = color == Chess::ChessNotation::WHITE_PLAYER ? 'K' : 'k'
      each_square do |piece, row_index, col_index|
        return Position.new(row_index, col_index) if piece == target_piece
      end
    end

    def find_all_pieces(color)
      pieces = []
      each_square do |piece, row, column|
        next if piece.nil?

        if PieceHelpers.friendly_piece?(color: color, target_piece: piece)
          pieces << { position: Position.new(row, column), piece: piece }
        end
      end
      pieces
    end

    # command to update grid state when piece moves
    def update_position(start_pos, end_pos)
      piece = piece_at(start_pos)
      place_piece(end_pos, piece)
      erase_origin_position(start_pos)
    end

    def place_piece(position, piece)
      @grid[position.row][position.column] = piece
    end

    # 4 steps to a move:
    # 1. check move is valid
    # 2. create new position
    # 3. update board state (grid, flags, etc.)
    # 4. return status
    def try_move(move)
      return :no_piece if possible_move.empty?
      return :illegal_move unless valid_move?(move)

      play_move(move)
      :success
    end

    def valid_move?(move)
      MoveValidator.move_legal?(self, move)
    end

    def play_move(move)
      update_position(move.from_position, move.to_position)
      update_castling_rights(move)
      update_en_passant_square(move)
    end

    private

    def each_square
      grid.each_with_index do |rank, row_index|
        rank.each_with_index do |piece, col_index|
          yield(piece, row_index, col_index)
        end
      end
    end

    def possible_moves(position)
      return [] if piece_at(position).nil?

      generate_possible_moves(position, piece_at(position))
    end

    def erase_origin_position(start_pos)
      @grid[start_pos.row][start_pos.column] = nil
    end

    def update_en_passant_square(move)
      @en_passant_square = nil # reset en passant square
      if %w[p P].include?(move.piece) && pawn_advanced_two_squares?(move)
      end
    end

    def pawn_advanced_two_squares?(move); end
  end
end


================================================
FILE: ./lib/chess/core/game.rb
================================================
# frozen_string_literal: true

module Chess
  # Game defines a game object
  # which handles game logic.
  # It orchestrates creating board
  # objects, switching player
  # turns, checking for game over
  # and win conditions, etc.
  #
  # @example Create a new Game
  # game = Game.new
  class Game
    attr_accessor :active_color, :half_move_clock,
                  :full_move_number
    attr_reader :board, :move_history

    def initialize(active_color: ChessNotation::WHITE_PLAYER,
                   board: Board.start_positions,
                   half_move_clock: 0,
                   full_move_number: 1,
                   move_history: MoveHistory.new)
      @active_color = active_color
      @board = board
      @half_move_clock = half_move_clock
      @full_move_number = full_move_number
      @move_history = move_history
      @game_over = false
    end

    def self.from_fen(fen_string)
      game_board = Board.from_fen(fen_string)
      game_data = FromFEN.to_game_data(fen_string)
      new(board: game_board, **game_data)
    end

    def to_fen
      ToFEN.create_fen(build_fen_data)
    end

    def play
      start
      until game_over?
        play_turn
        switch_turn unless game_over?
      end
      announce_game_end
    end

    def start
      Interface.welcome
      Display.show_board(board.to_display)
    end

    def switch_turn
      @active_color = PieceHelpers.opponent_color(active_color)
    end

    def game_over?
      @game_over || checkmate? || stalemate? || draw_by_rule?
    end

    def winner
      return nil unless game_over?
      return nil if stalemate? || draw_by_rule?

      PieceHelpers.opponent_color(active_color)
    end

    private

    def build_fen_data
      {
        active_color: active_color,
        half_move_clock: half_move_clock,
        full_move_number: full_move_number
      }.merge(board_fen_data)
    end

    def board_fen_data
      board.to_fen
    end

    def play_turn
      move = Interface.request_move
      move = Interface.request_move until board.try_move[:success]
      update_game_state(move)
      Display.show_board(board.to_display)
    end

    def checkmate?
      false
    end

    def stalemate?
      false
    end

    def draw_by_rule?
      threefold_repetition? || fifty_move_rule?
    end

    def threefold_repetition?
      move_history.threefold_repetition?
    end

    def fifty_move_rule?
      half_move_clock >= 100
    end

    def announce_game_end
      if winner
        announce_winner
      else
        announce_end
      end
    end

    def announce_winner
      puts "Checkmate! Game over. #{winner == 'w' ? 'White' : 'Black'} won!"
    end

    def announce_end
      puts "Game over. It's a draw."
    end
  end
end


================================================
FILE: ./lib/chess/core/move_history.rb
================================================
# frozen_string_literal: true

require 'digest/md5'

module Chess
  class MoveHistory
    attr_accessor :move_history, :past_positions

    def initialize(move_history = [], past_positions = [])
      @move_history = move_history
      @past_positions = past_positions
    end

    def add_move(move)
      @move_history << move
      add_to_position(move.fen)
    end

    # for 50 move rule
    def count_moves
      move_history.count
    end

    def threefold_repetition?
      return true if count_duplicate_positions.values.any? { |count| count >= 3 }

      false
    end

    # hash position for threefold repetition rule,
    # which omits move clocks from consideration
    def add_to_position(fen_string)
      position = fen_position(fen_string)
      @past_positions << hash_position(position) if position
    end

    def has_moved?(starting_position)
      move_history.any? { |move| move.from_position == starting_position }
    end

    private

    # hash isn't strictly necessary as the FEN string is sufficient
    def hash_position(partial_fen_string)
      Digest::MD5.hexdigest(partial_fen_string.to_s)
    end

    def count_duplicate_positions
      return nil if past_positions.nil?

      count = Hash.new(0)
      past_positions.each { |position| count[position] += 1 }
      count
    end

    def fen_position(fen_string)
      FromFEN.to_piece_placement(fen_string)
    end
  end
end


================================================
FILE: ./lib/chess/core/move.rb
================================================
# frozen_string_literal: true

module Chess
  # Tracks a Move object
  # to record important properties
  # about a move. This is useful
  # for building a move history
  # and later for calculating
  # threefold repetition.
  class Move
    attr_reader :from_position, :to_position, :piece, :captured_piece,
                :castling, :en_passant_target, :promotion,
                :double_pawn_move, :fen

    def initialize(
      from_position:,
      to_position:,
      piece:,
      captured_piece: nil,
      castling: nil,
      en_passant_target: nil,
      promotion: nil,
      double_pawn_move: nil,
      fen: nil
    )
      validate_position(from_position)
      validate_position(to_position)

      @from_position = from_position
      @to_position = to_position
      @piece = piece
      @captured_piece = captured_piece
      @castling = castling
      @en_passant_target = en_passant_target
      @promotion = promotion
      @double_pawn_move = double_pawn_move
      @fen = fen
    end

    private

    def validate_position(position)
      raise ArgumentError, "#{position} must be a Position object" unless position.is_a?(Position)

      raise ArgumentError, "#{position.coordinates} is out of bounds" unless position.in_bound?
    end

    def validate_capture(opponent_piece); end
  end
end


================================================
FILE: ./lib/chess/core/position.rb
================================================
# frozen_string_literal: true

module Chess
  # Position defines a position on
  # the chess game board.
  #
  # It contains the data about a
  # position on the grid.
  #
  # @example Create a new Position
  # position = Position.new(row, column)
  #
  class Position
    include ChessNotation
    extend ChessNotation
    attr_reader :row, :column

    def self.from_coordinates(row_index, column_index)
      new(row_index, column_index)
    end

    # a2, d1, f8, g7, etc.
    def self.from_algebraic(algebraic_notation)
      rank, file = split_square_to_rank_file(algebraic_notation)
      row = rank_to_row(rank)
      column = file_to_col(file)
      new(row, column)
    end

    def self.from_directional_vector(array)
      row = array.first
      column = array.last
      new(row, column)
    end

    def initialize(row, column)
      @row = row
      @column = column
    end

    def rank
      return nil unless in_bound?

      row_to_rank(row)
    end

    def file
      return nil unless in_bound?

      col_to_file(column)
    end

    def square
      return nil unless in_bound?

      "#{col_to_file(column)}#{row_to_rank(row)}"
    end

    def coordinates
      return nil unless in_bound?

      [row, column]
    end

    def ==(other)
      row == other.row && column == other.column
    end

    def in_bound?
      return true if row.between?(0, Config::GRID_LENGTH - 1) &&
                     column.between?(0, Config::GRID_LENGTH - 1)

      false
    end

    # Parameter takes in a new position object with delta coordinates
    def transform_coordinates(position_delta)
      new_position = Position.new(
        position_delta.row + row, position_delta.column + column
      )
      new_position if new_position.in_bound?
    end

    def +(other)
      transform_coordinates(other)
    end

    def -(other)
      Position.new(row - other.row, column - other.column)
    end

    def two_rank_move?(other)
      (row - other.row).abs == 2
    end

    def diagonal_move?(other)
      row_delta = (row - other.row).abs
      column_delta = (column - other.column).abs
      (row_delta == column_delta) && row_delta.positive?
    end
  end
end


================================================
FILE: ./lib/chess/data/config.rb
================================================
# frozen_string_literal: true

# Configuration stores game settings.
module Chess
  module Config
    GRID_LENGTH = 8
    RGB_COLOR_MAP = {
      white: '232;235;239',
      black: '35;65;75'
    }.freeze
    EMPTY_SQUARE_PADDING = '   '
    PIECE_PADDING = ' '
  end
end


================================================
FILE: ./lib/chess/data/directions_data.rb
================================================
# frozen_string_literal: true

module Chess
  # Directions Data saves the data
  # for the directional vectors for
  # easier move calculation. This
  # avoids having to remember the
  # delta numbers, especially which
  # direction is negative.
  #
  # It also stores the piece
  # movement vectors
  module Directions
    PAWN_WHITE = [
      [-1, 0],  # white forward
      [-2, 0],  # 2 forward
      [-1, -1], # diagonal_forward_left
      [-1, 1]   # diagonal_forward_right
    ].freeze
    PAWN_BLACK = [
      [1, 0],   # black forward
      [2, 0],   # 2 forward
      [1, 1],   # diagonal_forward_left
      [1, -1]   # diagonal_forward_right
    ].freeze
    KNIGHT = [
      [-1, 2], [1, 2], [2, 1], [2, -1],
      [1, -2], [-1, -2], [-2, -1], [-2, 1]
    ].freeze
    ROOK = [[-1, 0], [1, 0], [0, 1], [0, -1]].freeze
    BISHOP = [[1, 1], [1, -1], [-1, 1], [-1, -1]].freeze
  end
end


================================================
FILE: ./lib/chess/data/piece_data.rb
================================================
# frozen_string_literal: true

module Chess
  # Piece Data provides the different
  # chess pieces's data and
  # initial positions.
  module Piece
    ALLOWED_COLORS = %i[w b].freeze
    PIECE_SYMBOLS = {
      'K' => '♔', 'k' => '♚',
      'Q' => '♕', 'q' => '♛',
      'R' => '♖', 'r' => '♜',
      'B' => '♗', 'b' => '♝',
      'N' => '♘', 'n' => '♞',
      'P' => '♙', 'p' => '♟'
    }.freeze
    START_POSITIONS = {
      [0, 0] => 'r',
      [0, 1] => 'n',
      [0, 2] => 'b',
      [0, 3] => 'q',
      [0, 4] => 'k',
      [0, 5] => 'b',
      [0, 6] => 'n',
      [0, 7] => 'r',
      [1, 0] => 'p',
      [1, 1] => 'p',
      [1, 2] => 'p',
      [1, 3] => 'p',
      [1, 4] => 'p',
      [1, 5] => 'p',
      [1, 6] => 'p',
      [1, 7] => 'p',
      [6, 0] => 'P',
      [6, 1] => 'P',
      [6, 2] => 'P',
      [6, 3] => 'P',
      [6, 4] => 'P',
      [6, 5] => 'P',
      [6, 6] => 'P',
      [6, 7] => 'P',
      [7, 0] => 'R',
      [7, 1] => 'N',
      [7, 2] => 'B',
      [7, 3] => 'Q',
      [7, 4] => 'K',
      [7, 5] => 'B',
      [7, 6] => 'N',
      [7, 7] => 'R'
    }.freeze
  end
end


================================================
FILE: ./lib/chess/helpers/chess_notation.rb
================================================
# frozen_string_literal: true

module Chess
  # Helper methods to use Chess
  # Notation in Chess game
  module ChessNotation
    FILES = %w[a b c d e f g h].freeze
    WHITE_PLAYER = :white
    BLACK_PLAYER = :black
    NEITHER_CASTLE_RIGHTS = '-'
    WHITE_CASTLE_KINGSIDE = 'K'
    WHITE_CASTLE_QUEENSIDE = 'Q'
    BLACK_CASTLE_KINGSIDE = 'k'
    BLACK_CASTLE_QUEENSIDE = 'q'

    def col_to_file(column_index)
      FILES.fetch(column_index)
    end

    def row_to_rank(row_index)
      return (Config::GRID_LENGTH - row_index).to_s if row_index.between?(0, Config::GRID_LENGTH - 1)

      raise ArgumentError, "Invalid row index #{row_index}, must be 0 to 7."
    end

    def coord_to_rank_file(column_index, row_index)
      col_to_file(column_index).to_s + row_to_rank(row_index).to_s
    end

    def rank_to_row(rank)
      return (Config::GRID_LENGTH - rank.to_i) if rank.to_i.between?(1, Config::GRID_LENGTH)

      raise ArgumentError, "Invalid rank #{rank}, must be 1 to 8."
    end

    def file_to_col(file)
      FILES.find_index { |f| f == file }
    end

    def rank_file_to_coord(algebraic_notation)
      rank, file = split_square_to_rank_file(algebraic_notation)
      [rank_to_row(rank), file_to_col(file)]
    end

    def split_square_to_rank_file(algebraic_notation)
      rank = algebraic_notation.chars.last
      file = algebraic_notation.chars.first
      [rank, file]
    end

    def valid_rank?(rank)
      rank.to_i.positive? && rank.to_i.between?(1, Config::GRID_LENGTH)
    end

    def valid_file?(file)
      FILES.include?(file)
    end

    def valid_rank_file?(algebraic_notation)
      rank, file = split_square_to_rank_file(algebraic_notation)
      valid_rank?(rank) && valid_file?(file)
    end
  end
end


================================================
FILE: ./lib/chess/helpers/colorize_string.rb
================================================
# frozen_string_literal: true

module Chess
  # ColorizeString configures Terminal
  # output color settings
  # Credit: Josh Smith
  # https://dev.to/joshdevhub/terminal-colors-using-ruby-410p
  module ColorizeString
    refine String do
      def output_color(color_name, ground: fore)
        rgb_value = Config::RGB_COLOR_MAP[color_name]
        "\e[#{ground == 'fore' ? 38 : 48};2;#{rgb_value}m#{self}\e[0m"
      end
    end
  end
end


================================================
FILE: ./lib/chess/helpers/display.rb
================================================
# frozen_string_literal: true

require_relative 'colorize_string'

module Chess
  # Display defines how to display
  # the game board in Chess.
  #
  # It manages displaying the board,
  # the pieces, and colors. It
  # doesn't include the IO
  # functionality in the game.
  #
  # @example Create a new Board
  # board = Board.new
  #
  class Display
    using Chess::ColorizeString
    attr_reader :board_data

    def self.show_board(...)
      new(...).build_board_for_display
    end

    def initialize(board_data)
      @board_data = board_data
    end

    def map_piece_symbol(code)
      Chess::Piece::PIECE_SYMBOLS[code]
    end

    def build_board_for_display
      board_data.map.with_index do |rank, rank_index|
        format_rank(rank, rank_index)
      end.join("\n")
    end

    private

    def format_rank(rank, rank_index)
      rank.map.with_index do |piece_code, file_index|
        format_square(piece_code, rank_index, file_index)
      end.join
    end

    def format_square(piece_code, rank_index, file_index)
      combined_indices = rank_index + file_index
      apply_style_rules(combined_indices, piece_code)
    end

    def apply_style_rules(index, piece_code)
      content = apply_whitespace_style(piece_code)
      apply_background_color(index, content)
    end

    def apply_whitespace_style(piece_code)
      return Chess::Config::EMPTY_SQUARE_PADDING if piece_code.empty?

      "#{Chess::Config::PIECE_PADDING}#{map_piece_symbol(piece_code)}#{Chess::Config::PIECE_PADDING}"
    end

    def apply_background_color(index, content)
      # "white on the right"
      color = index.even? ? :white : :black
      content.output_color(color, ground: 'back')
    end
  end
end


================================================
FILE: ./lib/chess/helpers/from_fen.rb
================================================
# frozen_string_literal: true

module Chess
  # Helper methods to convert
  # Forsyth–Edwards Notation
  # into a Chess game
  class FromFEN
    attr_reader :fen_string

    def self.parse_fen(...)
      new(...).parse_fen
    end

    def self.to_piece_placement(...)
      new(...).parse_fen_for_piece_placement
    end

    def self.to_game_data(...)
      new(...).parse_fen_for_game_data
    end

    def initialize(fen_string)
      @fen_string = fen_string
    end

    # starting position FEN:
    # rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
    def parse_fen
      fen_fields = fen_string.split
      return nil unless fen_fields.length == 6

      split_fen_string(fen_fields)
    end

    # return only first 4 fields for Board.new
    def parse_fen_for_piece_placement
      fields = parse_fen
      fields.delete_if do |key, _v|
        key.to_s.include?('move') ||
          key.to_s.include?('active')
      end
    end

    def parse_fen_for_game_data
      fields = parse_fen
      fields.slice(:active_color, :half_move_clock, :full_move_number)
    end

    private

    # parse fen string helper methods
    def split_fen_string(fen_fields)
      castling_rights = fen_fields[2]

      {
        grid: parse_piece_placement(fen_fields[0]),
        active_color: convert_fen_active_color(fen_fields[1]),
        castling_rights: build_castling_rights(castling_rights),
        en_passant_square: en_passant_to_position(fen_fields[3]),
        half_move_clock: fen_fields[4].to_i,
        full_move_number: fen_fields[5].to_i
      }
    end

    def parse_piece_placement(grid_data)
      ranks = grid_data.split('/')
      ranks.map do |rank|
        expand_rank_notation(rank)
      end
    end

    def expand_rank_notation(rank)
      rank.chars.flat_map do |char|
        if char.match?(/\d/)
          Array.new(char.to_i, nil)
        else
          char
        end
      end
    end

    def build_castling_rights(castling_string)
      {
        white_castle_kingside: can_castle?(castling_string, ChessNotation::WHITE_CASTLE_KINGSIDE),
        white_castle_queenside: can_castle?(castling_string, ChessNotation::WHITE_CASTLE_QUEENSIDE),
        black_castle_kingside: can_castle?(castling_string, ChessNotation::BLACK_CASTLE_KINGSIDE),
        black_castle_queenside: can_castle?(castling_string, ChessNotation::BLACK_CASTLE_QUEENSIDE)
      }
    end

    def can_castle?(castling_symbol, castle_type)
      castling_symbol.include?(castle_type)
    end

    def en_passant_to_position(field)
      return nil if field == '-'

      Position.from_algebraic(field)
    end

    def convert_fen_active_color(fen_string)
      fen_string == 'w' ? :white : :black
    end
  end
end


================================================
FILE: ./lib/chess/helpers/interface.rb
================================================
# frozen_string_literal: true

# Interface defines a game IO
# in Chess.
#
# It displays messages to the
# user and receives input for
# game play. It also verifies
# and cleanses user input.
#
module Chess
  module Interface
    def self.welcome
      puts <<~WELCOME
        ♔♟️ Welcome to Chess. You will play a Chess game in the console.
        We will have 2 players represented by color, white and black.
        As with traditional chess games, white moves first.
      WELCOME
    end

    def self.show(grid)
      grid.each do |row|
        puts "| #{row.map { |cell| cell.nil? ? '  ' : map_color(cell) }.join(' ')} |"
      end
    end

    def self.announce_turn(name)
      puts "#{name}, it's your turn."
    end

    def self.request_column
      puts <<~MESSAGE
        🔮 Which column do you want drop a piece into?
      MESSAGE
      column = gets.chomp.delete(' ').to_i
      valid_column?(column) ? column : request_column_again
    end

    def self.display_invalid_column_message
      puts '❌ Invalid column number. Please pick again.'
    end

    def self.request_name
      puts "What's your name?"
      gets.chomp
    end

    def self.valid_column?(input)
      input.between?(1, 7)
    end

    def self.request_symbol
      puts 'What color do you want? 🔴 🔵 🟡 🟣'
      puts "Type #{COLORS.split.join('  ')}"
      symbol = gets.chomp.delete(' ')
      valid_color?(symbol) ? symbol : request_color_again
    end

    def self.valid_color?(symbol)
      return false unless symbol.length == 1

      COLORS.include?(symbol)
    end

    def self.map_color(symbol)
      case symbol
      when 'r'
        '🔴'
      when 'b'
        '🔵'
      when 'y'
        '🟡'
      else
        '🟣'
      end
    end

    def self.request_color_again
      puts '❌ Invalid symbol color.'
      request_symbol
    end
  end
end


================================================
FILE: ./lib/chess/helpers/piece_helpers.rb
================================================
# frozen_string_literal: true

module Chess
  module PieceHelpers
    # checks if the captured piece is an enemy color
    def self.opponent_color?(attack_piece:, captured_piece:)
      (attack_piece.match?(/[A-Z]/) && captured_piece.match?(/[a-z]/)) ||
        (attack_piece.match?(/[a-z]/) && captured_piece.match?(/[A-Z]/))
    end

    def self.opponent_color(active_color)
      active_color == Chess::ChessNotation::WHITE_PLAYER ? Chess::ChessNotation::BLACK_PLAYER : Chess::ChessNotation::WHITE_PLAYER
    end

    def self.friendly_piece?(color:, target_piece:)
      # if it's white's piece
      if color == Chess::ChessNotation::WHITE_PLAYER
        target_piece.match?(/[A-Z]/)
      elsif color == Chess::ChessNotation::BLACK_PLAYER
        target_piece.match?(/[a-z]/)
      end
    end
  end
end


================================================
FILE: ./lib/chess/helpers/to_fen.rb
================================================
# frozen_string_literal: true

module Chess
  # Helper methods to convert current
  # game state to Forsyth–Edwards
  # Notation in Chess game
  class ToFEN
    attr_reader :fen_data

    def self.create_fen(...)
      new(...).create_fen
    end

    def initialize(fen_data)
      @fen_data = fen_data
    end

    # starting position FEN:
    # rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
    # create fen string from fen_data (hash data structure)
    def create_fen
      fen_string = ''
      fen_string += "#{build_piece_placement(fen_data[:grid])} "
      fen_string += "#{convert_fen_active_color(fen_data[:active_color])} "
      fen_string += "#{build_castling_rights(fen_data[:castling_rights])} "
      fen_string += "#{build_en_passant(fen_data[:en_passant_square])} "
      fen_string += "#{fen_data[:half_move_clock]} "
      fen_string + fen_data[:full_move_number].to_s
    end

    private

    # create fen string helper methods
    def build_piece_placement(grid)
      grid.map.with_index do |rank, _index|
        build_rank(rank)
      end.join('/')
    end

    def build_rank(rank)
      grouped_squares = rank.slice_when { |left, right| left.nil? != right.nil? }.to_a
      count_if_nils(grouped_squares).join
    end

    def count_if_nils(grouped_squares)
      grouped_squares.map do |group|
        if group.first.nil?
          group.length.to_s # convert nil count to string
        else
          group.join # join piece data without count
        end
      end
    end

    def build_castling_rights(castling_rights)
      rights = ''
      rights += 'K' if castling_rights[:white_castle_kingside]
      rights += 'Q' if castling_rights[:white_castle_queenside]
      rights += 'k' if castling_rights[:black_castle_kingside]
      rights += 'q' if castling_rights[:black_castle_queenside]
      rights.empty? ? '-' : rights
    end

    def build_en_passant(square)
      return '-' if square.nil?

      square
    end

    def convert_fen_active_color(color)
      p color
      color == :white ? 'w' : 'b'
    end
  end
end


================================================
FILE: ./lib/chess/services/castling_validator.rb
================================================
# frozen_string_literal: true

module Chess
  # Check rules for castling rights.
  # This class contains methods to
  # ensure castling moves are allowed.
  module Castling
    def self.castling_legal?(...)
      new(...).can_castle?
    end

    def initialize(move, move_history = [])
      @king_start = move.from_position
      @king_end = move.to_position
      @piece = move.piece
      @rook_position = move.castling
      @move_history = move_history
    end

    def can_castle?
      return false if king_has_moved?
      return false if rook_has_moved?
      return false if king_in_check?(board, move)
      return false if path_in_check?(board, move)
      return false if castling_into_check?(board, move)

      true
    end

    private

    def king_has_moved?
      move_history.has_moved?(king_start)
    end

    def rook
      move_history.has_moved?
    end
  end
end


================================================
FILE: ./lib/chess/services/check_detector.rb
================================================
# frozen_string_literal: true

module Chess
  class CheckDetector
    attr_reader :board, :active_color

    def self.in_check?(...)
      new(...).in_check?
    end

    def initialize(board, active_color)
      @board = board
      @active_color = active_color
    end

    def in_check?
      king_position = board.find_king(active_color)
      return false unless king_position

      opponent_color = PieceHelpers.opponent_color(active_color)
      # retrieve data on all of opponent's pieces & their positions
      opponent_pieces = board.find_all_pieces(opponent_color)
      # calculate all moves possible from opponent pieces
      opponent_moves = find_all_pieces_moves(opponent_pieces)
      find_king_in_opponent_moves?(king_position, opponent_moves)
    end

    private

    def find_all_pieces_moves(piece_data)
      possible_move_positions = []
      piece_data.each do |position, piece|
        possible_move_positions << MoveCalculator.new(position[:position], piece)
      end
      possible_move_positions
    end

    def find_king_in_opponent_moves?(king_position, opponent_moves)
      opponent_moves.find { |position| position == king_position }
    end
  end
end


================================================
FILE: ./lib/chess/services/move_calculator.rb
================================================
# frozen_string_literal: true

module Chess
  # Move Calculator generates the
  # possible moves each piece can
  # make.
  #
  # For example, the #pawn_moves
  # returns all forward moves, such
  # as 1 square advance, 2 square
  # advance, and 1 square diagonal
  # capture.
  #
  # It does NOT validate
  # the moves. Validation happens
  # in Move Validator with the help
  # of specialty validation modules.
  #
  # It does NOT make the moves.
  class MoveCalculator
    include Directions
    attr_reader :position, :piece

    def self.generate_possible_moves(...)
      new(...).generate_possible_moves
    end

    def initialize(position, piece)
      @position = position
      @piece = piece
    end

    def generate_possible_moves
      # move direction of pawn depends on color
      return pawn_moves if %w[p P].include?(piece)
      # empty square
      return [] if piece.nil?

      case piece.downcase
      when 'k'
        king_moves
      when 'q'
        queen_moves
      when 'b'
        bishop_moves
      when 'n'
        knight_moves
      when 'r'
        rook_moves
      else
        []
      end.compact # compact handles out of bounds positions
    end

    def calculate_moves(directional_vectors, max_distance = 7)
      moves = []
      directional_vectors.each do |vector|
        (1..max_distance).each do |distance|
          row_delta = vector.first * distance
          column_delta = vector.last * distance
          delta_position = Position.from_coordinates(row_delta, column_delta)
          moves << (position + delta_position)
        end
      end
      moves
    end

    private

    def knight_moves
      KNIGHT.map do |vector|
        position + Position.from_directional_vector(vector)
      end.compact
    end

    def rook_moves
      calculate_moves(Directions::ROOK)
    end

    def bishop_moves
      calculate_moves(Directions::BISHOP)
    end

    def queen_moves
      vectors = Directions::ROOK + Directions::BISHOP
      calculate_moves(vectors)
    end

    def king_moves
      vectors = Directions::ROOK + Directions::BISHOP
      calculate_moves(vectors, 1)
    end

    # includes all possible move forward (1 square advance, 1 diagonal
    # square capture, 2 squares advance)
    def pawn_moves
      vectors = piece == 'p' ? Directions::PAWN_BLACK : Directions::PAWN_WHITE
      calculate_moves(vectors, 1)
    end
  end
end


================================================
FILE: ./lib/chess/services/move_validator.rb
================================================
# frozen_string_literal: true

module Chess
  # Move Validator performs checks
  # to ensure the move is valid
  # before allow the move to
  # persist and update the board/
  # game state.
  #
  # Move Validator may call upon
  # helper classes to perform
  # specialty validations, such as
  # check.
  class MoveValidator
    attr_reader :board, :move, :start_position, :end_position, :piece,
                :move_history

    def self.move_legal?(...)
      new(...).move_legal?
    end

    # def self.two_square_pawn_move?()
    def initialize(board, move, move_history = [])
      @board = board
      @move = move
      @start_position = move.from_position
      @end_position = move.to_position
      @piece = move.piece
      @move_history = move_history
    end

    def move_legal?
      return false unless possible_move?
      return false unless valid_destination?
      return false unless clear_path?
      return false unless valid_piece_moves?

      true
    end

    private

    def possible_move?
      all_moves = MoveCalculator.generate_possible_moves(start_position, piece)
      all_moves.include?(end_position)
    end

    def valid_destination?
      target_piece = board.piece_at(end_position)

      if target_piece.nil? # empty square
        true
      else
        PieceHelpers.opponent_color?(attack_piece: piece, captured_piece: target_piece)
      end
    end

    def clear_path?
      return true if %w[n N].include?(piece)

      path = calculate_path_between(start_position, end_position)
      empty_square_along_path?(path)
    end

    # find all the squares between start and destination positions
    def calculate_path_between(start_position, end_position)
      total_row_delta = end_position.row - start_position.row
      total_column_delta = end_position.column - start_position.column
      direction_vector = [convert_direction(total_row_delta), convert_direction(total_column_delta)]
      steps = [total_row_delta.abs, total_column_delta.abs].max
      request_moves(direction_vector, steps)
    end

    # are there any pieces along the piece's movement path?
    def empty_square_along_path?(path)
      route = path[0...-1] # remove destination square
      return true if route.all? { |position| board.piece_at(position).nil? }

      false
    end

    def convert_direction(delta)
      return 0 if delta.zero?

      delta.positive? ? 1 : -1
    end

    def request_moves(direction_vector, steps)
      calculator = MoveCalculator.new(start_position, piece)
      calculator.calculate_moves([direction_vector], steps)
    end

    def valid_piece_moves?
      return PawnMoveValidator.valid_move?(move, move_history) if %w[P p].include?(piece)

      # other pieces return true as they don't have piece-specific moves
      true
    end
  end
end


================================================
FILE: ./lib/chess/services/pawn_move_validator.rb
================================================
# frozen_string_literal: true

module Chess
  # PawnMoveValidator handles pawn-specific
  # move validation rules that go beyond
  # the basic move generation.
  #
  # It validates:
  # - Diagonal moves only for captures
  # - Two-square moves only for unmoved pawns
  # - Forward moves only to empty squares
  class PawnMoveValidator
    attr_reader :start_position, :end_position, :piece, :captured_piece,
                :move_history

    def self.valid_move?(...)
      new(...).valid_move?
    end

    def initialize(move, move_history = [])
      @start_position = move.from_position
      @end_position = move.to_position
      @piece = move.piece
      @captured_piece = move.captured_piece
      @move_history = move_history
    end

    def valid_move?
      if start_position.diagonal_move?(end_position)
        capture_move_valid? # pawn can't move to an empty square
      else
        forward_move_valid?
      end
    end

    private

    def capture_move_valid?
      # Pawns move diagonally only for capturing
      return false unless captured_piece

      # must only capture enemy pieces
      PieceHelpers.opponent_color?(attack_piece: piece, captured_piece: captured_piece)
    end

    def forward_move_valid?
      # If pawn tries to move 2 squares, it must not have moved before
      return false if start_position.two_rank_move?(end_position) && pawn_has_moved?

      # Pawn can move 1 square forward. Move directions limited in MoveCalculator
      # Destination is empty is checked in MoveValidator
      true
    end

    def pawn_has_moved?
      move_history.has_moved?(start_position)
    end
  end
end


================================================
FILE: ./main.rb
================================================
# frozen_string_literal: true

# main contains the main execution
# for running a Chess game

require_relative 'lib/game'

loop do
  game = Game.new
  game.start
  game.play
  puts 'Play again? Enter y for yes (y): '
  break unless gets.chomp.downcase == 'y'
end


================================================
FILE: ./README.md
================================================
# odin-chess-ruby
The Odin Project's capstone Chess project

Let's plan and outline the project before writing code.

Chess has many layers: 
1. setting up a board, placing pieces - DONE
2. displaying the board and different colors - DONE
- Chess Notation - DONE
- FEN Notation - DONE
3. basic movement for one piece - DONE
- generating all possible moves - DONE
- validating the moves
  1. possible move? - DONE
  2. validate destination? - DONE
  -- either empty square - DONE
  -- or capturing enemy piece - DONE
  -- path is clear
  3. castling_available?
  -- have castle & rook moved?
  -- empty squares in between?
  -- king in check?
  4. en_passant_allowed?
  5. legal_pawn_moves?
  -- 2 square forward if not moved
  -- diagonal capture
  -- en passant
  -- promotion
  6. check & checkmate - leave_king_in_check?
4. expanding to all pieces and movements for all pieces - DONE
4a. expanding validation checks to all pieces
5. game state management 
- switching turns
- adding check and checkmate (includes win & game over)
6. saving game state
- export & load game state 
7. adding advanced moves, e.g. castling, en passant, promotion

# Composed Systems 

## main.rb
Purpose: Entry point and main execution
- Creates a new Game
- Sets up game loop and repeat play if player chooses y
Instance variables: None
Instance method:
- Scripted loop
-- Create new game
-- Start
-- play

## Game
Purpose: Game flow controller
- It tells collaborators to take actions
- It tells collaborators to check things  
Instance Method:
- tracks state of board - whose turn is it?
- checks check & checkmate 
- delegates to saving the game state
- loads new games

## Board class
Purpose: Manages game rules, delegates to helpers
Instance variable:
- 2D array chess board
Instance methods:
- Move execution (store result of move)
- Updating board
Instance variables:
Instance methods:
TBD

## Rules Engine module
Purpose: Calculate all valid moves
- generates all moves
- discards invalid moves


## Interface module
Purpose: Controls IO and delegates to helpers
Instance methods:
- Request player name
- Get's player move input
- Displays board
- Displays win & game over announcements

### Display module
Purpose: Helps Display board and pieces
- Job to make the board look user friendly

### DataValidator
- Validates & cleanses inputs

### ChessNotation

## MoveFinder
Purpose: Find all possible moves, including
validating en passant, castling, and promotion
possibilities for every player's turn

# Value Objects

## Position
Purpose: Holds x, y coordinates, or row & column

## Move

# Interaction Stories

## Display a new game board
A new Game begins. The Game asks the Interface to 
display the current board. The Interface displays
the Board. It shows all Pieces in the correct 
beginning Positions. No Piece has yet made any Moves.

## Player makes a move
When a player wants to make a move, Interface asks &
accepts the player's move request. Game tells 
Board to make the move. Board tells MoveFinder to discover
all possible moves. Board tells MoveValidator to 
validate if the move is legal. If legal,
Game tells Board to update its state. Board clears the
"from" position and updates the "to" position with the 
moved Piece. Board updates relevant flags.
Game saves the game state. Game 
asks Interface to display the updated Game.
Game needs to check for check or checkmate. If
the game isn't over, Game switches which 
player's turn it is. 

If illegal, Game tells Interface to ask Player to
provide another move.


================================================
FILE: ./spec/chess/core/board_spec.rb
================================================
# frozen_string_literal: true

require_relative '../../../lib/chess'

# Tests for the Chess Board class

describe Chess::Board do
  subject(:start_board) { described_class.start_positions }

  let(:first_rank) { 7 }
  let(:second_rank) { 6 }
  let(:seventh_rank) { 1 }
  let(:eighth_rank) { 0 }
  let(:a_file) { 0 }
  let(:c_file) { 2 }
  let(:e_file) { 4 }
  let(:h_file) { 7 }

  describe '.start_positions' do
    context 'when the board is created' do
      it 'adds white pawns to the second rank (row)' do
        start_pos = Chess::Position.from_algebraic('a2')
        expect(start_board.piece_at(start_pos)).to eq('P')
      end

      it 'adds white rooks' do
        initial_pos_queenside = Chess::Position.from_coordinates(first_rank, a_file)
        initial_pos_kingside = Chess::Position.from_coordinates(first_rank, h_file)
        expect(start_board.piece_at(initial_pos_queenside)).to eq('R')
        expect(start_board.piece_at(initial_pos_kingside)).to eq('R')
      end

      it 'adds white king' do
        start_pos = Chess::Position.from_coordinates(first_rank, e_file)
        expect(start_board.piece_at(start_pos)).to eq('K')
      end

      it 'adds black pawns to the 7th rank (row)' do
        start_pos = Chess::Position.from_algebraic('a7')
        expect(start_board.piece_at(start_pos)).to eq('p')
      end

      it 'adds black king' do
        start_pos = Chess::Position.from_coordinates(eighth_rank, e_file)
        expect(start_board.piece_at(start_pos)).to eq('k')
      end

      it 'adds a black bishop' do
        start_pos = Chess::Position.from_coordinates(eighth_rank, c_file)
        expect(start_board.piece_at(start_pos)).to eq('b')
      end
    end
  end

  describe '.from_fen' do
    context 'when creating a new board from a fen string' do
      subject(:starting_board) { described_class.from_fen(starting_fen) }

      let(:starting_fen) { 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1' }

      it 'returns a white pawn at a2' do
        white_pawn_pos = Chess::Position.from_algebraic('a2')
        expect(starting_board.piece_at(white_pawn_pos)).to eq('P')
      end

      it 'returns a black king at e8' do
        black_king_pos = Chess::Position.from_algebraic('e8')
        expect(starting_board.piece_at(black_king_pos)).to eq('k')
      end

      it 'returns all pieces have castling rights' do
        expect(starting_board.castling_rights.values).to all(be true)
      end

      it 'returns nil for en passant square' do
        expect(starting_board.en_passant_square).to be_nil
      end
    end

    context 'when starting a midway game from fen' do
      subject(:mid_game_board) { described_class.from_fen(after_move_fen) }

      let(:after_move_fen) { 'rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1' }

      it 'returns a white pawn at e4' do
        white_pawn_pos = Chess::Position.from_algebraic('e4')
        expect(mid_game_board.piece_at(white_pawn_pos)).to eq('P')
      end

      it 'returns true for all 4 castling rights' do
        expect(mid_game_board.castling_rights.values).to all(be true)
      end

      it 'returns e3 for en passant square' do
        en_passant_pos = Chess::Position.from_algebraic('e3')
        expect(mid_game_board.en_passant_square).to eq(en_passant_pos)
      end
    end

    context 'when loading an end game from fen' do
      subject(:end_game_board) { described_class.from_fen(end_game_fen) }

      let(:end_game_fen) { '3B4/K7/2k1b1p1/1p2Pp1p/3P3P/2P3P1/8/8 w - - 0 74' }

      it 'returns a white king at a7' do
        white_king_pos = Chess::Position.from_algebraic('a7')
        expect(end_game_board.piece_at(white_king_pos)).to eq('K')
      end

      it 'returns false for all 4 castling rights' do
        expect(end_game_board.castling_rights.values).to all(be false)
      end

      it 'returns nil for en passant square' do
        expect(end_game_board.en_passant_square).to be_nil
      end
    end
  end

  describe '#to_display' do
    context 'when starting a new game' do
      it 'returns a display string with the same number of lines as the grid board' do
        result = start_board.to_display
        expect(result).to be_an(Array)
        expect(result.size).to eq(Chess::Config::GRID_LENGTH)
      end
    end
  end

  describe '#piece_at' do
    context 'when the white rook is at h1' do
      let(:rook_position) { Chess::Position.from_algebraic('h1') }

      it 'returns R, the symbol for white rook' do
        result = start_board.piece_at(rook_position)
        expect(result).to eq('R')
      end
    end

    context 'when there is an empty square at d4' do
      let(:empty_square) { Chess::Position.from_algebraic('d4') }

      it 'returns nil' do
        result = start_board.piece_at(empty_square)
        expect(result).to be_nil
      end
    end
  end

  describe '#update_position' do
    context 'when moving a white pawn to an empty square' do
      let(:start_pos) { Chess::Position.from_algebraic('d2') }
      let(:end_pos) { Chess::Position.from_algebraic('d3') }

      it 'places the piece at the destination' do
        original_piece = start_board.piece_at(start_pos)
        start_board.update_position(start_pos, end_pos)
        expect(start_board.piece_at(end_pos)).to eq(original_piece)
      end

      it 'removes the piece from the origin position' do
        start_board.update_position(start_pos, end_pos)
        expect(start_board.piece_at(start_pos)).to be_nil
      end
    end

    context 'when capturing an opponent piece' do
      let(:attacker_pos) { Chess::Position.new(1, 0) }
      let(:target_pos) { Chess::Position.new(6, 0) }

      it 'replaces the target piece with the attacking piece' do
        attacking_piece = start_board.piece_at(attacker_pos)
        start_board.update_position(attacker_pos, target_pos)
        expect(start_board.piece_at(target_pos)).to eq(attacking_piece)
      end
    end
  end

  describe '#valid_move?' do
    let(:knight_start) { Chess::Position.from_algebraic('d5') }
    let(:knight_destination) { Chess::Position.from_algebraic('c3') }
    let(:move) { Chess::Move.new(from_position: knight_start, to_position: knight_destination, piece: 'N') }

    it 'delegates to MoveValidator' do
      expect(Chess::MoveValidator).to receive(:move_legal?).with(start_board, move)
      start_board.valid_move?(move)
    end
  end

  describe '#find_king' do
    context 'when starting a new game' do
      it 'returns e1 for white king' do
        expected_position = Chess::Position.from_algebraic('e1')
        expect(start_board.find_king(Chess::ChessNotation::WHITE_PLAYER)).to eq(expected_position)
      end

      it 'returns e8 for black king' do
        expected_position = Chess::Position.from_algebraic('e8')
        expect(start_board.find_king(Chess::ChessNotation::BLACK_PLAYER)).to eq(expected_position)
      end
    end

    context 'when placing a black king on e6' do
      start_pos = Chess::Position.from_algebraic('e8')
      end_pos = Chess::Position.from_algebraic('e6')
      before do
        start_board.update_position(start_pos, end_pos)
      end

      it 'returns e6 for moved black king' do
        expect(start_board.find_king(Chess::ChessNotation::BLACK_PLAYER)).to eq(end_pos)
      end
    end
  end

  describe '#find_all_pieces' do
    context "when starting a new game (which starts as white's move)" do
      it 'returns all black pieces with positions' do
        expected_positions = starting_positions(Chess::ChessNotation::BLACK_PLAYER)
        actual_positions = start_board.find_all_pieces(Chess::ChessNotation::BLACK_PLAYER)
                                      .map { |data| data[:position] }
        expect(actual_positions).to match_array(expected_positions)
      end

      context 'when the game has pieces in starting positions' do
        it "returns all white pieces when it is black's move" do
          expected_positions = starting_positions(Chess::ChessNotation::WHITE_PLAYER)
          actual_positions = start_board.find_all_pieces(Chess::ChessNotation::WHITE_PLAYER)
                                        .map { |data| data[:position] }
          expect(actual_positions).to match_array(expected_positions)
        end
      end

      context 'when all black pieces are requested' do
        it 'returns only black pieces' do
          black_pieces = start_board.find_all_pieces(Chess::ChessNotation::BLACK_PLAYER)
          expect(black_pieces.length).to eq(16)
          expect(black_pieces.map { |data| data[:piece] }).to all(match(/[a-z]/))
        end
      end
      context 'when all white pieces are requested' do
        it 'returns only white pieces' do
          white_pieces = start_board.find_all_pieces(Chess::ChessNotation::WHITE_PLAYER)
          expect(white_pieces.length).to eq(16)
          expect(white_pieces.map { |data| data[:piece] }).to all(match(/[A-Z]/))
        end
      end
    end

    private

    def starting_positions(active_color)
      regex = active_color == Chess::ChessNotation::WHITE_PLAYER ? /[A-Z]/ : /[a-z]/
      # Use existing Piece data about starting positions
      Chess::Piece::START_POSITIONS.select { |_, symbol| symbol.match?(regex) }
                                   .keys # gets the position info in array
                                   .map { |pos| Chess::Position.new(pos.first, pos.last) }
    end

    def positions_for_color(board, active_color)
      board.find_all_pieces(active_color)
           .map { |data| Chess::Position.new(data[:position].first, data[:position].last) }
    end
  end
end


================================================
FILE: ./spec/chess/core/game_spec.rb
================================================
# frozen_string_literal: true

require_relative '../../../lib/chess'

# Tests for the Chess Game class

describe Chess::Game do
  let(:start_game) { described_class.new }
  let(:end_game) { described_class.new }

  describe '.from_fen' do
    context 'when creating a new game from start positions' do
      let(:starting_fen) { 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1' }

      it "returns that it is white's turn to move" do
        result = start_game.active_color
        expect(result).to eq(Chess::ChessNotation::WHITE_PLAYER)
      end

      it 'returns 0 for half move clock' do
        expect(start_game.half_move_clock).to eq(0)
      end

      it 'returns 1 for full move number' do
        expect(start_game.full_move_number).to eq(1)
      end
    end

    context 'when loading a midway game from fen' do
      subject(:midway_game) { described_class.from_fen(after_move_fen) }

      let(:after_move_fen) { 'rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1' }

      it 'returns active player color is black' do
        expect(midway_game.active_color).to eq(Chess::ChessNotation::BLACK_PLAYER)
      end

      it 'returns 0 for half move clock' do
        expect(midway_game.half_move_clock).to eq(0)
      end

      it 'returns 1 for full move number' do
        expect(midway_game.full_move_number).to eq(1)
      end
    end

    context 'when loading an end game from fen' do
      subject(:end_game) { described_class.from_fen(end_game_fen) }

      let(:end_game_fen) { '3B4/K7/2k1b1p1/1p2Pp1p/3P3P/2P3P1/8/8 w - - 0 74' }

      it 'returns active player color is white' do
        expect(end_game.active_color).to eq(Chess::ChessNotation::WHITE_PLAYER)
      end

      it 'returns 0 for half move clock' do
        expect(end_game.half_move_clock).to eq(0)
      end

      it 'returns 74 for full move number' do
        expect(end_game.full_move_number).to eq(74)
      end
    end
  end

  describe '#to_fen' do
    context 'when starting a new game' do
      it 'returns the fen piece placement data in the correct order' do
        result = start_game.to_fen
        starting_fen = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'
        expect(result).to eq(starting_fen)
      end
    end

    context 'when creating FEN from a midway game' do
      subject(:midway_game) { described_class.from_fen(mid_game_fen) }

      let(:mid_game_fen) { 'rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 1 2' }

      it 'returns the same FEN as loaded in' do
        result = midway_game.to_fen
        expect(result).to eq(mid_game_fen)
      end
    end

    context 'when creating FEN from end game' do
      subject(:end_game) { described_class.from_fen(end_game_fen) }

      let(:end_game_fen) { '3b2k1/1p3p2/p1p5/2P4p/1P2P1p1/5p2/5P2/4RK2 w - - 0 0' }

      it 'returns the same FEN as loaded in' do
        result = end_game.to_fen
        expect(result).to eq(end_game_fen)
      end
    end

    context 'when creating FEN from Fischer vs Byrne, 1956 game after queen sacrifice' do
      subject(:game_of_the_century) { described_class.from_fen(game_of_the_century_fen) }

      let(:game_of_the_century_fen) { 'r3r1k1/pp3ppp/1qn2n2/3p1b2/3P1B2/2N2N2/PP2QPPP/2RR2K1 b - - 0 18' }

      it 'results in same FEN as loaded in' do
        result = game_of_the_century.to_fen
        expect(result).to eq(game_of_the_century_fen)
      end
    end
  end

  describe '#play' do
    before do
      allow(Chess::Interface).to receive(:welcome)
      allow(Chess::Display).to receive(:show_board)
      allow(start_game).to receive(:puts)
    end

    context 'when game starts and ends immediately' do
      before do
        allow(start_game).to receive(:play_turn) do
          start_game.instance_variable_set(:@game_over, true)
        end
      end

      it 'calls start' do
        expect(start_game).to receive(:start)
        start_game.play
      end

      it 'calls announce_game_end' do
        expect(start_game).to receive(:announce_game_end)
        start_game.play
      end
    end
  end

  describe '#start' do
    context 'when starting the game from initial positions' do
      subject(:new_game) { described_class.from_fen(starting_fen) }

      let(:starting_fen) { 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1' }
      let(:mock_board_data) do
        [
          ['r', 'n', Chess::ChessNotation::BLACK_PLAYER, 'q', 'k', Chess::ChessNotation::BLACK_PLAYER, 'n', 'r'],
          ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
          ['', '', '', '', '', '', '', ''],
          ['', '', '', '', '', '', '', ''],
          ['', '', '', '', '', '', '', ''],
          ['', '', '', '', '', '', '', ''],
          ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
          ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ]
      end

      it 'returns white as the active player color' do
        current_player = new_game.active_color
        expect(current_player).to eq(Chess::ChessNotation::WHITE_PLAYER)
      end

      it 'returns starting position fen string' do
        result = new_game.to_fen
        expect(result).to eq(starting_fen)
      end

      it 'sends a welcome message' do
        allow(Chess::Display).to receive(:show_board)
        allow(Chess::Interface).to receive(:welcome)
        expect(Chess::Interface).to receive(:welcome)
        new_game.start
      end

      it 'displays the board' do
        allow(Chess::Interface).to receive(:welcome)
        board_mock = instance_double(Chess::Board)
        allow(board_mock).to receive(:to_display).and_return(mock_board_data)
        game = described_class.new(board: board_mock)
        expect(Chess::Display).to receive(:show_board).with(mock_board_data)
        game.start
      end
    end
  end

  describe '#switch_turn' do
    context 'after white makes a move' do
      it 'sends a message to switch to black' do
        expect { start_game.switch_turn }.to change(start_game, :active_color)
          .from(Chess::ChessNotation::WHITE_PLAYER).to(Chess::ChessNotation::BLACK_PLAYER)
        start_game.switch_turn
      end
    end
  end

  describe '#game_over?' do
    context 'when the game just started' do
      it 'returns false' do
        expect(start_game.game_over?).to be false
      end
    end

    context 'when checkmate? is true' do
      it 'returns true' do
        allow(end_game).to receive(:checkmate?).and_return(true)
        expect(end_game).to be_game_over
      end
    end

    context 'when draw by rule is true' do
      it 'returns true' do
        allow(end_game).to receive(:draw_by_rule?).and_return(true)
        expect(end_game).to be_game_over
      end
    end
  end

  describe '#winner' do
    context 'when game is not over' do
      it 'returns nil' do
        expect(start_game.winner).to be_nil
      end
    end

    context 'when black checkmates' do
      it 'returns black as the winner' do
        allow(end_game).to receive(:game_over?).and_return(true)
        expect(end_game.winner).to eq(Chess::ChessNotation::BLACK_PLAYER)
      end
    end
  end
end


================================================
FILE: ./spec/chess/core/move_history_spec.rb
================================================
# frozen_string_literal: true

require_relative '../../../lib/chess'

# Tests for Move History class

describe Chess::MoveHistory do
  subject(:history_from_start) { described_class.new }

  describe '#add_move' do
    context 'when the first move completes' do
      let(:knight_start) { Chess::Position.from_algebraic('b1') }
      let(:knight_destination) { Chess::Position.from_algebraic('c3') }
      let(:fen) { 'rnbqkbnr/pppppppp/8/8/8/2N5/PPPPPPPP/R1BQKBNR b KQkq - 1 1' }
      let(:knight_move) do
        Chess::Move.new(from_position: knight_start, to_position: knight_destination, piece: 'N', fen: fen)
      end

      it 'increases the move count by 1' do
        expect { history_from_start.add_move(knight_move) }.to change(history_from_start, :count_moves).by(1)
      end

      it 'return false for threefold repetition?' do
        history_from_start.add_move(knight_move)
        result = history_from_start.threefold_repetition?
        expect(result).to be false
      end
    end
  end

  describe '#threefold_repetition?' do
    context 'when no position repeats three times' do
      it 'returns false for normal game progression' do
        normal_game_fens = [
          'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1',
          'rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1',
          'rnbqkbnr/pp1ppppp/8/2p5/4P3/8/PPPP1PPP/RNBQKBNR w KQkq c6 0 2',
          'rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 1 2',
          'r1bqkbnr/pp1ppppp/2n5/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 2 3',
          'r1bqkbnr/pp1ppppp/2n5/2p5/3PP3/5N2/PPP2PPP/RNBQKB1R b KQkq d3 0 3'
        ]
        normal_game_fens.each { |fen| history_from_start.add_to_position(fen) }
        result = history_from_start.threefold_repetition?
        expect(result).to be false
      end
    end

    context 'when Polgar vs. Kasparov, 2002 led to perpetual check draw' do
      it 'returns true for threefold repetition' do
        threefold_repetition_fens = [
          '2r3k1/5pp1/3p3p/3Pp3/1p2P1P1/1P2BP2/5P1P/4R1K1 w - - 0 30',
          '2r3k1/5pp1/3p3p/3Pp3/1p2P1P1/1P2BP2/4QP1P/4R1K1 b - - 1 30',
          '2r5/4kpp1/3p3p/3Pp3/1p2P1P1/1P2BP2/4QP1P/4R1K1 w - - 2 31',
          '2r5/4kpp1/3p3p/3Pp2Q/1p2P1P1/1P2BP2/5P1P/4R1K1 b - - 3 31',
          '2r3k1/5pp1/3p3p/3Pp2Q/1p2P1P1/1P2BP2/5P1P/4R1K1 w - - 4 32',
          '2r3k1/5pp1/3p3p/3Pp3/1p2P1P1/1P2BP2/4QP1P/4R1K1 b - - 5 32',
          '2r5/4kpp1/3p3p/3Pp3/1p2P1P1/1P2BP2/4QP1P/4R1K1 w - - 6 33',
          '2r5/4kpp1/3p3p/3Pp2Q/1p2P1P1/1P2BP2/5P1P/4R1K1 b - - 7 33',
          '2r3k1/5pp1/3p3p/3Pp2Q/1p2P1P1/1P2BP2/5P1P/4R1K1 w - - 8 34',
          '2r3k1/5pp1/3p3p/3Pp3/1p2P1P1/1P2BP2/4QP1P/4R1K1 b - - 9 34',
          '2r5/4kpp1/3p3p/3Pp3/1p2P1P1/1P2BP2/4QP1P/4R1K1 w - - 10 35',
          '2r5/4kpp1/3p3p/3Pp2Q/1p2P1P1/1P2BP2/5P1P/4R1K1 b - - 11 35'
        ]
        threefold_repetition_fens.each { |fen| history_from_start.add_to_position(fen) }
        expect(history_from_start.threefold_repetition?).to be true
      end
    end

    context 'when knights position repeats leading to draw' do
      it 'returns true for threefold repetition' do
        fens_knight_repetition = [
          'r1bq1rk1/pp2nppp/2n1p3/3p4/2PP4/2N1PN2/PP3PPP/R1BQKB1R w KQ - 0 10',
          'r1bq1rk1/pp2nppp/2n1p3/3p4/2PP4/2N1PN2/PP2BPPP/R1BQK2R b KQ - 1 10',
          'r1bq1rk1/pp2nppp/4p3/1n1p4/2PP4/2N1PN2/PP2BPPP/R1BQK2R w KQ - 2 11',
          'r1bq1rk1/pp2nppp/4p3/1n1p4/2PP4/4PN2/PP1NBPPP/R1BQK2R b KQ - 3 11',
          'r1bq1rk1/pp2nppp/2n1p3/3p4/2PP4/4PN2/PP1NBPPP/R1BQK2R w KQ - 4 12',
          'r1bq1rk1/pp2nppp/2n1p3/3p4/2PP4/2N1PN2/PP2BPPP/R1BQK2R b KQ - 5 12',
          'r1bq1rk1/pp2nppp/4p3/1n1p4/2PP4/2N1PN2/PP2BPPP/R1BQK2R w KQ - 6 13',
          'r1bq1rk1/pp2nppp/4p3/1n1p4/2PP4/4PN2/PP1NBPPP/R1BQK2R b KQ - 7 13',
          'r1bq1rk1/pp2nppp/2n1p3/3p4/2PP4/4PN2/PP1NBPPP/R1BQK2R w KQ - 8 14',
          'r1bq1rk1/pp2nppp/2n1p3/3p4/2PP4/2N1PN2/PP2BPPP/R1BQK2R b KQ - 9 14',
          'r1bq1rk1/pp2nppp/4p3/1n1p4/2PP4/2N1PN2/PP2BPPP/R1BQK2R w KQ - 10 15',
          'r1bq1rk1/pp2nppp/4p3/1n1p4/2PP4/4PN2/PP1NBPPP/R1BQK2R b KQ - 11 15'
        ]
        fens_knight_repetition.each { |fen| history_from_start.add_to_position(fen) }
        expect(history_from_start.threefold_repetition?).to be true
      end
    end
  end

  describe '#has_moved?' do
    context 'when the game starts and no moves have been recorded' do
      let(:start_board) { Chess::Board.start_positions(add_pieces: true) }

      it 'returns false for white pawn' do
        start_pos = Chess::Position.from_algebraic('d2')
        expect(history_from_start.has_moved?(start_pos)).to be false
      end

      it 'returns false for black king' do
        start_pos = Chess::Position.from_algebraic('e8')
        expect(history_from_start.has_moved?(start_pos)).to be false
      end
    end

    context 'when moves have been recorded' do
      let(:pawn_start) { Chess::Position.from_algebraic('e2') }
      let(:pawn_destination) { Chess::Position.from_algebraic('e4') }
      let(:pawn_move) do
        Chess::Move.new(
          from_position: pawn_start,
          to_position: pawn_destination,
          piece: 'P',
          fen: 'rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1'
        )
      end
      let(:knight_start) { Chess::Position.from_algebraic('g1') }
      let(:knight_destination) { Chess::Position.from_algebraic('f3') }
      let(:knight_move) do
        Chess::Move.new(
          from_position: knight_start,
          to_position: knight_destination,
          piece: 'N',
          fen: 'rnbqkbnr/pppppppp/8/8/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 1 1'
        )
      end

      before do
        history_from_start.add_move(pawn_move)
        history_from_start.add_move(knight_move)
      end

      it 'returns true for pawn that moved' do
        expect(history_from_start.has_moved?(pawn_start)).to be true
      end

      it 'returns true for the knight that moved' do
        expect(history_from_start.has_moved?(knight_start)).to be true
      end

      it 'returns false for a position that has not moved' do
        unmoved_position = Chess::Position.from_algebraic('e1')
        expect(history_from_start.has_moved?(unmoved_position)).to be false
      end
    end

    context 'when the same rook has moved and moves back to its initial position' do
      let(:rook_origin) { Chess::Position.from_algebraic('a8') }
      let(:rook_moved_pos) { Chess::Position.from_algebraic('a7') }

      let(:first_rook_move) do
        Chess::Move.new(
          from_position: rook_origin,
          to_position: rook_moved_pos,
          piece: 'r',
          fen: '1rbqkbnr/rppppppp/p1n5/8/8/8/PPPPPPPP/RNBQKBNR w KQq - 1 4'
        )

        let(:second_rook_move) do
          Chess::Move.new(
            from_position: rook_moved_pos,
            to_position: rook_origin,
            piece: 'r',
            fen: 'r1bqkbnr/1ppppppp/p1n5/8/8/8/PPPPPPPP/RNBQKBNR b KQq - 2 4'
          )
        end
        before do
          history_from_start.add_move(first_rook_move)
          history_from_start.add_move(second_rook_move)
        end

        it 'returns true for the original starting position even after returning' do
          expect(history_from_start.has_moved?(rook_origin)).to be true
        end

        it 'returns true for the intermediate position the rook moved to' do
          expect(history_from_start.has_moved?(rook_moved_pos)).to be true
        end
      end
    end
  end
end


================================================
FILE: ./spec/chess/core/move_spec.rb
================================================
# frozen_string_literal: true

require_relative '../../../lib/chess'

# Tests for the Move class

describe Chess::Move do
  let(:valid_from_position) { Chess::Position.from_algebraic('b2') }
  let(:valid_to_position) { Chess::Position.from_algebraic('b4') }

  describe '#initialize' do
    context 'when creating from valid positions' do
      it 'creates a move successfully' do
        expect do
          described_class.new(
            from_position: valid_from_position,
            to_position: valid_to_position,
            piece: 'P',
            captured_piece: 'p',
            double_pawn_move: true
          )
        end.not_to raise_error
      end

      context 'when given invalid positions' do
        let(:invalid_position) { double('invalid_position') }

        before do
          allow(invalid_position).to receive(:is_a?)
            .with(Chess::Position).and_return(false)
        end

        it 'raises an ArgumentError' do
          expect do
            described_class.new(
              from_position: invalid_position,
              to_position: valid_to_position,
              piece: 'p'
            )
          end.to raise_error(ArgumentError, /must be a Position object/)
        end
      end

      context 'when given an out of bounds object' do
        let(:out_of_bounds_position) { double('out_of_bounds_position') }

        before do
          allow(out_of_bounds_position).to receive(:is_a?)
            .with(Chess::Position).and_return(true)
          allow(out_of_bounds_position).to receive_messages(in_bound?: false, coordinates: [9, 9])
        end

        it 'raises ArgumentError for out-of-bounds from_position' do
          expect do
            described_class.new(
              from_position: out_of_bounds_position,
              to_position: valid_to_position,
              piece: 'R'
            )
          end.to raise_error(ArgumentError, /is out of bounds/)
        end
      end
    end
  end
end


================================================
FILE: ./spec/chess/core/position_spec.rb
================================================
# frozen_string_literal: true

require_relative '../../../lib/chess'

# Tests for the Chess Position class

describe Chess::Position do
  let(:top_left_position) { described_class.from_coordinates(0, 0) }
  let(:top_right_position) { described_class.from_coordinates(0, 7) }
  let(:bottom_left_position) { described_class.from_coordinates(7, 0) }
  let(:bottom_right_position) { described_class.from_coordinates(7, 7) }

  describe '.from_coordinates' do
    context 'when passing in the topmost leftmost square' do
      it 'returns the position using array index coordinates' do
        result = top_left_position.square
        expect(result).to eq('a8')
      end
    end

    context 'when passing in the bottom rightmost square' do
      it 'returns the position using array index coordinates' do
        result = bottom_right_position.square
        expect(result).to eq('h1')
      end
    end
  end

  describe '.from_algebraic' do
    context 'when creating a position from chess notation' do
      it 'returns the position of e4' do
        result = described_class.from_algebraic('e4')
        expect(result.coordinates).to eq([4, 4])
      end

      it 'returns the position of h8' do
        result = described_class.from_algebraic('h8')
        expect(result).to eq(top_right_position)
      end
    end
  end

  describe '#rank' do
    it 'returns 8 for a8, top left square, when the row is 0 index' do
      expect(top_left_position.rank).to eq('8')
    end

    it 'returns 1 for h1, bottom right square, when the row is 7 index' do
      expect(bottom_right_position.rank).to eq('1')
    end

    it 'returns nil for an out-of-bounds position' do
      negative_direction = described_class.from_directional_vector(Chess::Directions::PAWN_WHITE[0])
      expect(negative_direction.rank).to be_nil
    end
  end

  describe '#file' do
    it 'returns a for a8, top left square, when the column is 0 index' do
      expect(top_left_position.file).to eq('a')
    end

    it 'returns h for h8, top right square, when the column is 7 index' do
      expect(top_right_position.file).to eq('h')
    end

    it 'returns nil for an out-of-bounds position' do
      described_class.from_directional_vector(Chess::Directions::PAWN_WHITE[0])
    end
  end

  describe 'square' do
    it 'returns a1, bottom left square, when coordinates are [0, 7]' do
      expect(bottom_left_position.square).to eq('a1')
    end

    it 'returns h1, bottom right square, when coordinates are [7, 7]' do
      expect(bottom_right_position.square).to eq('h1')
    end

    it 'returns nil for an out-of-bounds position' do
      negative_direction = described_class.from_directional_vector(Chess::Directions::KNIGHT[0])
      expect(negative_direction.square).to be_nil
    end
  end

  describe 'coordinates' do
    it 'returns [0, 3] on square d8' do
      middle_position = described_class.from_algebraic('d8')
      expect(middle_position.coordinates).to eq([0, 3])
    end

    it 'returns [6, 7] on square h2' do
      end_position = described_class.from_algebraic('h2')
      expect(end_position.coordinates).to eq([6, 7])
    end

    it 'returns nil if out-of-bounds position' do
      negative_direction = described_class.from_directional_vector(Chess::Directions::ROOK[0])
      expect(negative_direction.coordinates).to be_nil
    end
  end

  describe '#==' do
    it 'returns true when the positions are the same' do
      test_position = described_class.from_coordinates(0, 0)
      result = top_left_position == test_position
      expect(result).to be true
    end

    it 'returns false when the positions are not the same' do
      result = top_left_position == bottom_right_position
      expect(result).to be false
    end
  end

  describe '#in_bound?' do
    context 'when the coordinates are inside the game board' do
      it 'returns true for top left position' do
        result = top_left_position.in_bound?
        expect(result).to be true
      end

      it 'returns true for top right position' do
        result = top_right_position.in_bound?
        expect(result).to be true
      end

      it 'returns true for bottom right position' do
        result = bottom_right_position.in_bound?
        expect(result).to be true
      end

      it 'returns true for a coordinate in the middle of the board' do
        middle_position = described_class.from_coordinates(3, 4)
        result = middle_position.in_bound?
        expect(result).to be true
      end
    end

    context 'when the coordinates are outside the game board' do
      it 'returns false for a negative coordinate' do
        invalid_position = described_class.from_coordinates(-1, 0)
        result = invalid_position.in_bound?
        expect(result).to be false
      end

      it 'returns false for a big index' do
        invalid_position = described_class.from_coordinates(0, 99)
        result = invalid_position.in_bound?
        expect(result).to be false
      end
    end
  end

  describe '#transform_coordinates' do
    context 'when the white pawn is at starting position' do
      it 'returns the position 1 square up' do
        start_position = described_class.from_coordinates(6, 0)
        direction = described_class.from_directional_vector(Chess::Directions::PAWN_WHITE[0])
        destination = start_position.transform_coordinates(direction)
        expect(destination).to eq(described_class.from_coordinates(5, 0))
      end

      it 'returns the position 2 squares up' do
        start_position = described_class.from_coordinates(6, 1)
        direction = described_class.from_directional_vector([-2, 0])
        destination = start_position.transform_coordinates(direction)
        expect(destination).to eq(described_class.from_coordinates(4, 1))
      end

      it 'returns nil when new position is out of bounds' do
        start_position = described_class.from_algebraic('h6')
        direction = described_class.from_directional_vector(Chess::Directions::PAWN_BLACK[2])
        destination = start_position.transform_coordinates(direction)
        expect(destination).to be_nil
      end
    end
  end

  describe '#+' do
    context 'when using algebraic notation as black rook' do
      it 'returns the position 1 forward square advance to a7' do
        start_position = described_class.from_algebraic('a7')
        direction = described_class.from_directional_vector(Chess::Directions::PAWN_BLACK[0])
        destination = start_position + direction
        expect(destination).to eq(described_class.from_algebraic('a6'))
      end

      it 'returns the position 1 left square advance to b8' do
        start_position = described_class.from_algebraic('a7')
        direction = described_class.from_directional_vector(Chess::Directions::PAWN_BLACK[2])
        destination = start_position + direction
        expect(destination).to eq(described_class.from_algebraic('b6'))
      end
    end
  end

  describe '#-' do
    context 'when pawn moves 1 rank' do
      from_position = described_class.from_algebraic('a2')
      to_position = described_class.from_algebraic('a3')

      it 'returns a Position with 1 rank difference' do
        expect((from_position - to_position).row.abs).to eq(1)
      end
    end

    context 'when pawn moves 2 ranks' do
      from_position = described_class.from_algebraic('b2')
      to_position = described_class.from_algebraic('b4')

      it 'returns a Position with 2 rank difference' do
        expect((from_position - to_position).row.abs).to eq(2)
      end
    end
  end

  describe '#two_rank_move?' do
    context 'when white pawn advances two squares forward' do
      start_pos = described_class.from_algebraic('c2')
      destination = described_class.from_algebraic('c4')
      it 'returns true' do
        expect(start_pos.two_rank_move?(destination)).to be true
      end
    end
  end

  describe '#two_rank_move?' do
    context 'when black pawn advances two squares forward' do
      start_pos = described_class.from_algebraic('e7')
      destination = described_class.from_algebraic('e5')
      it 'returns true' do
        expect(start_pos.two_rank_move?(destination)).to be true
      end
    end
  end

  describe '#two_rank_move?' do
    context 'when queen advances one squares forward' do
      start_pos = described_class.from_algebraic('d4')
      destination = described_class.from_algebraic('d5')
      it 'returns false' do
        expect(start_pos.two_rank_move?(destination)).to be false
      end
    end
  end

  describe '#diagonal_move?'
  context 'when black pawn captures' do
    start_pos = described_class.from_algebraic('d7')
    destination = described_class.from_algebraic('e6')
    it 'returns true' do
      expect(start_pos.diagonal_move?(destination)).to be true
    end
  end

  context 'when white pawn captures' do
    start_pos = described_class.from_algebraic('e2')
    destination = described_class.from_algebraic('f3')
    it 'returns true' do
      expect(start_pos.diagonal_move?(destination)).to be true
    end
  end

  context 'when rook moves' do
    start_pos = described_class.from_algebraic('a1')
    destination = described_class.from_algebraic('a2')
    it 'returns true' do
      expect(start_pos.diagonal_move?(destination)).to be false
    end
  end
end


================================================
FILE: ./spec/chess/helpers/display_spec.rb
================================================
# frozen_string_literal: true

require_relative '../../../lib/chess'

# Tests for the Connect Four Display class

describe Chess::Display do
  describe '#map_piece_symbol' do
    subject(:display) { described_class.new(mock_board_data) }

    let(:mock_board_data) { [%w[r n b q k b n r]] }

    context 'when taking the raw pieces data as input' do
      Chess::Piece::PIECE_SYMBOLS.map do |code, symbol|
        it "shows the piece #{code} maps to the #{symbol}" do
          expect(display.map_piece_symbol(code)).to eq(symbol)
        end
      end
    end
  end

  describe '#show_board' do
    context 'when starting a new game' do
      let(:mock_board_data) do
        [
          ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
          ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
          ['', '', '', '', '', '', '', ''],
          ['', '', '', '', '', '', '', ''],
          ['', '', '', '', '', '', '', ''],
          ['', '', '', '', '', '', '', ''],
          ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
          ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ]
      end

      it 'DEBUG: shows the board visually', :debug do
        result = described_class.show_board(mock_board_data)
        puts "\nBoard State:\n#{result}\n" if RSpec.current_example.metadata[:debug]
        expect(result).to be_a(String)
      end

      it 'returns a string to print to the console' do
        result = described_class.show_board(mock_board_data)
        expect(result).to be_a(String)
      end

      it 'returns a string representation of the board' do
        white_king = '♔'
        white_knight = '♘'
        black_queen = '♛'
        black_pawn = '♟'
        result = described_class.show_board(mock_board_data)
        expect(result).to include(white_king).once
        expect(result).to include(white_knight).twice
        expect(result).to include(black_queen).once
        expect(result).to include(black_pawn).exactly(8).times
      end

      it 'returns the correct number of squares wide' do
        result = described_class.show_board(mock_board_data)
        expect(result.lines.count).to eq(Chess::Config::GRID_LENGTH)
      end
    end
  end
end


================================================
FILE: ./spec/chess/helpers/interface_spec.rb
================================================
# frozen_string_literal: true

require_relative '../../../lib/chess'

# Tests for the Connect Four Chess::Interface module

describe Chess::Interface do
  describe '.request_players_data' do
    context 'when game greets the players' do
      it "requests and return the players' info" do
        allow(described_class).to receive(:gets).and_return('Anna', 'p', 'Alex', 'y')
        expect(described_class.request_players_data).to eq({ 'Anna' => 'p', 'Alex' => 'y' })
      end
    end
  end

  describe '.request_column' do
    context 'when the player chooses a move' do
      let(:valid_move) { '3' }

      before do
        allow(described_class).to receive(:gets).and_return(valid_column)
      end

      it 'returns the column number' do
        expect(described_class.request_column).to eq(3)
      end

      context 'when the chosen column is invalid twice then valid' do
        let(:letter) { 'd' }
        let(:symbol) { '$' }
        let(:valid_input) { '6' }

        before do
          allow(described_class).to receive(:gets).and_return(letter, symbol, valid_input)
          allow(described_class).to receive(:puts)
        end

        it 'completes loop after two incorrect tries' do
          described_class.request_column
          expect(described_class).to have_received(:puts).with(/Invalid/).twice
          expect(described_class.request_column).to eq(6)
        end
      end
    end
  end
end


================================================
FILE: ./spec/chess/services/castling_validator_spec.rb
================================================
# frozen_string_literal: true

require_relative '../../../lib/chess'

# Tests for Castling class


================================================
FILE: ./spec/chess/services/check_detector.rb
================================================
# frozen_string_literal: true

require_relative '../../../lib/chess'

# Tests for Check Detector

describe Chess::CheckDetector do
  subject(:detector) { described_class }

  let(:board) { Chess::Board.start_positions(add_pieces: true) }

  describe '.in_check?' do
    context 'when starting a new game and king is not in check' do
      it 'returns false for white king' do
        expect(detector.in_check?(board, :white)).to be false
      end
    end
  end
end


================================================
FILE: ./spec/chess/services/move_calculator_spec.rb
================================================
# frozen_string_literal: true

require_relative '../../../lib/chess'

# Tests for the Chess Board class

describe Chess::MoveCalculator do
  subject(:calculator) { described_class.generate_possible_moves }

  let(:start_board) { Chess::Board.start_positions(add_pieces: true) }

  describe '#generate_possible_moves' do
    context 'when white knight from b1 moves from starting game positions' do
      it 'returns an array with 3 expected destinations' do
        start_pos = Chess::Position.from_algebraic('b1')
        expected_destinations = %w[c3 a3 d2].map { Chess::Position.from_algebraic(it) }
        expect(described_class.generate_possible_moves(start_pos, 'N')).to match_array(expected_destinations)
      end
    end

    context 'when black knight from g8 moves from starting game positions' do
      it 'returns an array with 3 expected destinations' do
        start_pos = Chess::Position.from_algebraic('g8')
        expected_destinations = %w[f6 h6 e7].map { Chess::Position.from_algebraic(it) }
        expect(described_class.generate_possible_moves(start_pos, 'n')).to match_array(expected_destinations)
      end
    end

    context 'when black rook from a8 moves from starting game position' do
      let(:black_rook) { Chess::Position.from_algebraic('a8') }

      it 'returns an array with 14 moves' do
        expect(described_class.generate_possible_moves(black_rook, 'r').length).to eq(14)
      end

      it 'returns the destination move of a6' do
        destination = Chess::Position.from_algebraic('a6')
        expect(described_class.generate_possible_moves(black_rook, 'r')).to include(destination)
      end
    end

    context 'when black bishop from c8 moves from starting game positions' do
      let(:black_bishop) { Chess::Position.from_algebraic('c8') }

      it 'returns an array with 7 positions' do
        expect(described_class.generate_possible_moves(black_bishop, 'b').length).to eq(7)
      end

      it 'returns the destination move of f5' do
        destination = Chess::Position.from_algebraic('f5')
        expect(described_class.generate_possible_moves(black_bishop, 'b')).to include(destination)
      end
    end

    context 'when white queen from d1 moves from starting game positions' do
      let(:white_queen) { Chess::Position.from_algebraic('d1') }

      it 'returns an array with 21 positions' do
        expect(described_class.generate_possible_moves(white_queen, 'Q').length).to eq(21)
      end

      it 'returns the destination move of f3' do
        destination = Chess::Position.from_algebraic('f3')
        expect(described_class.generate_possible_moves(white_queen, 'Q')).to include(destination)
      end
    end

    context 'when the black king from e8 moves from starting game positions' do
      let(:black_king) { Chess::Position.from_algebraic('e8') }

      it 'returns an array with 5 positions' do
        expect(described_class.generate_possible_moves(black_king, 'k').length).to eq(5)
      end

      it 'returns the destination move of e7' do
        destination = Chess::Position.from_algebraic('e7')
        expect(described_class.generate_possible_moves(black_king, 'k')).to include(destination)
      end
    end

    context 'when the white pawn at c2 moves' do
      it 'returns an array with 4 positions' do
        start_pos = Chess::Position.from_algebraic('c2')
        expected_destinations = %w[c3 c4 b3 d3].map { Chess::Position.from_algebraic(it) }
        expect(described_class.generate_possible_moves(start_pos, 'P')).to match_array(expected_destinations)
      end
    end

    context 'when the black pawn at g7 moves' do
      it 'returns an array with 4 positions' do
        start_pos = Chess::Position.from_algebraic('g7')
        expected_destinations = %w[f6 g6 h6 g5].map { Chess::Position.from_algebraic(it) }
        expect(described_class.generate_possible_moves(start_pos, 'p')).to match_array(expected_destinations)
      end
    end

    context 'when there is no piece at b5' do
      let(:empty_position) { Chess::Position.from_algebraic('b5') }

      it 'returns no piece symbol' do
        expect(described_class.generate_possible_moves(empty_position, nil)).to eq([])
      end
    end

    context 'when a white knight is at d5' do
      it 'returns 8 expected destination positions' do
        start_pos = Chess::Position.from_algebraic('d5')
        expected_destinations = %w[e7 f6 f4 e3 c3 b4 b6 c7].map { Chess::Position.from_algebraic(it) }
        expect(described_class.generate_possible_moves(start_pos, 'N')).to match_array(expected_destinations)
      end
    end
  end
end


================================================
FILE: ./spec/chess/services/move_validator_spec.rb
================================================
# frozen_string_literal: true

require_relative '../../../lib/chess'

# Tests for class Chess::Move Validator

describe Chess::MoveValidator do
  subject(:validator) { described_class.new }

  let(:board) { Chess::Board.new }

  describe '.move_legal?' do
    context 'when a white knight in the middle of an empty board moves' do
      let(:knight_start) { Chess::Position.from_algebraic('d5') }
      let(:knight_destination) { Chess::Position.from_algebraic('c3') }
      let(:move) { Chess::Move.new(from_position: knight_start, to_position: knight_destination, piece: 'N') }

      before do
        board.place_piece(knight_start, 'N')
      end

      it 'returns true when the destination square is empty' do
        result = described_class.move_legal?(board, move)
        expect(result).to be true
      end
    end

    context 'when a black rook moves diagonally' do
      it 'returns false' do
        rook_start = Chess::Position.from_algebraic('a8')
        rook_destination = Chess::Position.from_algebraic('f7')
        move = Chess::Move.new(from_position: rook_start, to_position: rook_destination, piece: 'N')
        board.place_piece(rook_start, 'N')
        expect(described_class.move_legal?(board, move)).to be false
      end
    end

    context 'when a black knight captures' do
      let(:knight_start) { Chess::Position.from_algebraic('f6') }
      let(:knight_destination) { Chess::Position.from_algebraic('e4') }
      let(:move) { Chess::Move.new(from_position: knight_start, to_position: knight_destination, piece: 'n') }

      before do
        board.place_piece(knight_start, 'n')
      end

      it 'returns true for a white pawn' do
        board.place_piece(knight_destination, 'P')
        expect(described_class.move_legal?(board, move)).to be true
      end

      it 'returns false for a black pawn' do
        board.place_piece(knight_destination, 'p')
        expect(described_class.move_legal?(board, move)).to be false
      end
    end

    context 'when starting a new game' do
      subject(:start_board) { Chess::Board.start_positions(add_pieces: true) }

      it 'returns false when white bishop path is blocked' do
        bishop_start = Chess::Position.from_algebraic('c1')
        bishop_destination = Chess::Position.from_algebraic('e3')
        move = Chess::Move.new(from_position: bishop_start, to_position: bishop_destination, piece: 'B')
        expect(described_class.move_legal?(start_board, move)).to be false
      end

      it 'returns true for white knight which can leap over pieces' do
        knight_start = Chess::Position.from_algebraic('b1')
        knight_destination = Chess::Position.from_algebraic('c3')
        move = Chess::Move.new(from_position: knight_start, to_position: knight_destination, piece: 'N')
        expect(described_class.move_legal?(board, move)).to be true
      end
    end

    context 'when validating a pawn move' do
      let(:white_pawn_start) { Chess::Position.from_algebraic('e2') }
      let(:white_pawn_destination) { Chess::Position.from_algebraic('e4') }
      let(:white_pawn_move) do
        Chess::Move.new(from_position: white_pawn_start, to_position: white_pawn_destination, piece: 'P')
      end
      let(:move_history) { [] }

      before do
        board.place_piece(white_pawn_start, 'P')
        allow(Chess::MoveCalculator).to receive(:generate_possible_moves)
          .and_return([white_pawn_destination])
        allow(Chess::PawnMoveValidator).to receive(:valid_move?).and_return(true)
      end

      it 'sends valid_move? message to PawnMoveValidator service' do
        expect(Chess::PawnMoveValidator).to receive(:valid_move?)
          .with(white_pawn_move, move_history)

        described_class.move_legal?(board, white_pawn_move, move_history)
      end
    end

    context 'when validating a black pawn move' do
      let(:black_pawn_start) { Chess::Position.from_algebraic('d7') }
      let(:black_pawn_destination) { Chess::Position.from_algebraic('d6') }
      let(:black_pawn_move) do
        Chess::Move.new(from_position: black_pawn_start, to_position: black_pawn_destination, piece: 'p')
      end
      let(:move_history) { [] }

      before do
        board.place_piece(black_pawn_start, 'p')
        # Stub the other validation methods to isolate the outgoing command test
        allow(Chess::MoveCalculator).to receive(:generate_possible_moves)
          .and_return([black_pawn_destination])
        allow(Chess::PawnMoveValidator).to receive(:valid_move?).and_return(true)
      end

      it 'sends valid_move? message to PawnMoveValidator with correct arguments' do
        expect(Chess::PawnMoveValidator).to receive(:valid_move?)
          .with(black_pawn_move, move_history)

        described_class.move_legal?(board, black_pawn_move, move_history)
      end
    end

    context 'when validating a non-pawn move' do
      let(:knight_start) { Chess::Position.from_algebraic('b1') }
      let(:knight_destination) { Chess::Position.from_algebraic('c3') }
      let(:knight_move) { Chess::Move.new(from_position: knight_start, to_position: knight_destination, piece: 'N') }
      let(:move_history) { [] }

      before do
        board.place_piece(knight_start, 'N')
        allow(Chess::MoveCalculator).to receive(:generate_possible_moves)
          .and_return([knight_destination])
      end

      it 'does not send valid_move? message to PawnMoveValidator' do
        expect(Chess::PawnMoveValidator).not_to receive(:valid_move?)

        described_class.move_legal?(board, knight_move, move_history)
      end
    end

    context 'when PawnMoveValidator returns false' do
      let(:invalid_pawn_start) { Chess::Position.from_algebraic('e3') }
      let(:invalid_pawn_destination) { Chess::Position.from_algebraic('e5') }
      let(:invalid_pawn_move) do
        Chess::Move.new(from_position: invalid_pawn_start, to_position: invalid_pawn_destination, piece: 'P')
      end
      let(:move_history) { [] }

      before do
        board.place_piece(invalid_pawn_start, 'P')
        allow(Chess::MoveCalculator).to receive(:generate_possible_moves)
          .and_return([invalid_pawn_destination])
        allow(Chess::PawnMoveValidator).to receive(:valid_move?).and_return(false)
      end

      it 'returns false when pawn validation fails' do
        result = described_class.move_legal?(board, invalid_pawn_move, move_history)
        expect(result).to be false
      end
    end
  end
end


================================================
FILE: ./spec/chess/services/pawn_move_validator_spec.rb
================================================
# frozen_string_literal: true

require_relative '../../../lib/chess'

# Tests for Pawn Move Validator

describe Chess::PawnMoveValidator do
  describe '.valid_move?' do
    let(:move) { instance_double(Chess::Move) }
    let(:move_history) { instance_double(Chess::MoveHistory) }
    let(:start_position) { double('start_position') }
    let(:end_position) { double('end_position') }

    before do
      allow(move).to receive_messages(from_position: start_position, to_position: end_position, piece: 'P',
                                      captured_piece: nil)
      allow(move_history).to receive(:has_moved?).and_return(false)
    end

    context 'when white pawn advances 1 rank to an empty square' do
      before do
        allow(start_position).to receive(:diagonal_move?)
          .with(end_position).and_return(false)
        allow(start_position).to receive(:two_rank_move?)
          .with(end_position).and_return(false)
      end

      it 'returns true' do
        result = described_class.valid_move?(move, move_history)
        expect(result).to be true
      end
    end

    context 'when white pawn advances 2 ranks to an empty square' do
      before do
        allow(start_position).to receive(:diagonal_move?)
          .with(end_position).and_return(false)
        allow(start_position).to receive(:two_rank_move?)
          .with(end_position).and_return(true)
        allow(move_history).to receive(:has_moved?)
          .with(start_position).and_return(false)
      end

      it 'returns true when pawn has not moved' do
        result = described_class.valid_move?(move, move_history)
        expect(result).to be true
      end
    end

    context 'when white pawn advances 2 ranks to an empty square' do
      before do
        allow(start_position).to receive(:diagonal_move?)
          .with(end_position).and_return(false)
        allow(start_position).to receive(:two_rank_move?)
          .with(end_position).and_return(true)
        allow(move_history).to receive(:has_moved?)
          .with(start_position).and_return(true)
      end

      it 'returns false when pawn has moved' do
        result = described_class.valid_move?(move, move_history)
        expect(result).to be false
      end
    end

    context 'when white pawn moves diagonally to capture' do
      let(:attacking_piece) { 'attacking_piece' }

      before do
        allow(start_position).to receive(:diagonal_move?)
          .with(end_position).and_return(true)
        allow(move).to receive(:piece).and_return(attacking_piece)
      end

      context 'when capturing an enemy piece' do
        let(:enemy_piece) { 'enemy_piece' }

        before do
          allow(move).to receive(:captured_piece).and_return(enemy_piece)
        end

        it 'returns true' do
          expect(Chess::PieceHelpers).to receive(:opponent_color?)
            .with(attack_piece: attacking_piece, captured_piece: enemy_piece).and_return(true)
          result = described_class.valid_move?(move, move_history)
          expect(result).to be true
        end
      end

      context 'when trying to capture a friendly piece' do
        let(:friendly_piece) { 'friendly_piece' }

        before do
          allow(move).to receive(:captured_piece).and_return(friendly_piece)
        end

        it 'returns false' do
          expect(Chess::PieceHelpers).to receive(:opponent_color?)
            .with(attack_piece: attacking_piece, captured_piece: friendly_piece).and_return(false)
          result = described_class.valid_move?(move, move_history)
          expect(result).to be false
        end
      end
    end

    context 'when white pawn moves diagonally to an empty square' do
      before do
        allow(start_position).to receive(:diagonal_move?)
          .with(end_position).and_return(true)
        allow(start_position).to receive(:captured_piece).and_return(nil)
      end

      it 'returns false' do
        result = described_class.valid_move?(move, move_history)
        expect(result).to be false
      end
    end

    context 'when black pawn moves diagonally to capture' do
      let(:attacking_piece) { 'attacking_piece' }

      before do
        allow(start_position).to receive(:diagonal_move?)
          .with(end_position).and_return(true)
        allow(move).to receive(:piece).and_return(attacking_piece)
      end

      context 'when capturing an enemy piece' do
        let(:enemy_piece) { 'enemy_piece' }

        before do
          allow(move).to receive(:captured_piece).and_return(enemy_piece)
        end

        it 'returns true' do
          expect(Chess::PieceHelpers).to receive(:opponent_color?)
            .with(attack_piece: attacking_piece, captured_piece: enemy_piece).and_return(true)
          result = described_class.valid_move?(move, move_history)
          expect(result).to be true
        end
      end

      context 'when capturing a friendly piece' do
        let(:friendly_piece) { 'friendly_piece' }

        before do
          allow(move).to receive(:captured_piece).and_return(friendly_piece)
        end

        it 'returns false' do
          expect(Chess::PieceHelpers).to receive(:opponent_color?)
            .with(attack_piece: attacking_piece, captured_piece: friendly_piece).and_return(false)
          result = described_class.valid_move?(move, move_history)
          expect(result).to be false
        end
      end
    end
  end
end


=========================================
END OF REPOSITORY STRUCTURE
=========================================
